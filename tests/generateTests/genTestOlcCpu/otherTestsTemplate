/*
package main

import (
    "flag"
    "os"
    "text/template"
)

type data struct {
    Type string
    Name string
}

func main() {
    var d data
    flag.StringVar(&d.Type, "type", "", "The subtype used for the queue being generated")
    flag.StringVar(&d.Name, "name", "", "The name used for the queue being generated. This should start with a capital letter so that it is exported.")
    flag.Parse()

    t := template.Must(template.New("queue").Parse(queueTemplate))
    if err := t.Execute(os.Stdout, d); err != nil {
        panic(err)
    }
}

var queueTemplate = `
package queue

import (
  "container/list"
)

func New{{.Name}}() *{{.Name}} {
  return &{{.Name}}{list.New()}
}

type {{.Name}} struct {
  list *list.List
}

func (q *{{.Name}}) Len() int {
  return q.list.Len()
}

func (q *{{.Name}}) Enqueue(i {{.Type}}) {
  q.list.PushBack(i)
}

func (q *{{.Name}}) Dequeue() {{.Type}} {
  if q.list.Len() == 0 {
    panic(ErrEmptyQueue)
  }
  raw := q.list.Remove(q.list.Front())
  if typed, ok := raw.({{.Type}}); ok {
    return typed
  }
  panic(ErrInvalidType)
}
`
/*

    # BIT (Absolute)

    def test_bit_abs_copies_bit_7_of_memory_to_n_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_bit_abs_copies_bit_7_of_memory_to_n_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_bit_abs_copies_bit_6_of_memory_to_v_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_bit_abs_copies_bit_6_of_memory_to_v_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_bit_abs_stores_result_of_and_in_z_preserves_a_when_1(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.ZERO
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0xFEED])

    def test_bit_abs_stores_result_of_and_when_nonzero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x01
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.ZERO)  # result of AND is non-zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x01, mpu.memory[0xFEED])

    def test_bit_abs_stores_result_of_and_when_zero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)  # result of AND is zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0xFEED])

    # BIT (Zero Page)

    def test_bit_zp_copies_bit_7_of_memory_to_n_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_bit_zp_copies_bit_7_of_memory_to_n_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_bit_zp_copies_bit_6_of_memory_to_v_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_bit_zp_copies_bit_6_of_memory_to_v_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_bit_zp_stores_result_of_and_in_z_preserves_a_when_1(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.ZERO
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0x0010])

    def test_bit_zp_stores_result_of_and_when_nonzero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x01
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.ZERO)  # result of AND is non-zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x01, mpu.memory[0x0010])

    def test_bit_zp_stores_result_of_and_when_zero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)  # result of AND is zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0x0010])

    # Compare instructions

    # See http://6502.org/tutorials/compare_instructions.html
    # and http://www.6502.org/tutorials/compare_beyond.html
    # Cheat sheet:
    #
    #    - Comparison is actually subtraction "register - memory"
    #    - Z contains equality result (1 equal, 0 not equal)
    #    - C contains result of unsigned comparison (0 if A<m, 1 if A>=m)
    #    - N holds MSB of subtraction result (*NOT* of signed subtraction)
    #    - V is not affected by comparison
    #    - D has no effect on comparison

    # CMP Immediate

    def test_cmp_imm_sets_zero_carry_clears_neg_flags_if_equal(self):
        """Comparison: A == m"""
        mpu = self._make_mpu()
        # $0000 CMP #10 , A will be 10
        self._write(mpu.memory, 0x0000, (0xC9, 10))
        mpu.a = 10
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_cmp_imm_clears_zero_carry_takes_neg_if_less_unsigned(self):
        """Comparison: A < m (unsigned)"""
        mpu = self._make_mpu()
        # $0000 CMP #10 , A will be 1
        self._write(mpu.memory, 0x0000, (0xC9, 10))
        mpu.a = 1
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE) # 0x01-0x0A=0xF7
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_cmp_imm_clears_zero_sets_carry_takes_neg_if_less_signed(self):
        """Comparison: A < #nn (signed), A negative"""
        mpu = self._make_mpu()
        # $0000 CMP #1, A will be -1 (0xFF)
        self._write(mpu.memory, 0x0000, (0xC9, 1))
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE) # 0xFF-0x01=0xFE
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY) # A>m unsigned

    def test_cmp_imm_clears_zero_carry_takes_neg_if_less_signed_nega(self):
        """Comparison: A < m (signed), A and m both negative"""
        mpu = self._make_mpu()
        # $0000 CMP #0xFF (-1), A will be -2 (0xFE)
        self._write(mpu.memory, 0x0000, (0xC9, 0xFF))
        mpu.a = 0xFE
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE) # 0xFE-0xFF=0xFF
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY) # A<m unsigned

    def test_cmp_imm_clears_zero_sets_carry_takes_neg_if_more_unsigned(self):
        """Comparison: A > m (unsigned)"""
        mpu = self._make_mpu()
        # $0000 CMP #1 , A will be 10
        self._write(mpu.memory, 0x0000, (0xC9, 1))
        mpu.a = 10
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE) # 0x0A-0x01 = 0x09
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY) # A>m unsigned

    def test_cmp_imm_clears_zero_carry_takes_neg_if_more_signed(self):
        """Comparison: A > m (signed), memory negative"""
        mpu = self._make_mpu()
        # $0000 CMP #$FF (-1), A will be 2
        self._write(mpu.memory, 0x0000, (0xC9, 0xFF))
        mpu.a = 2
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE) # 0x02-0xFF=0x01
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY) # A<m unsigned

    def test_cmp_imm_clears_zero_carry_takes_neg_if_more_signed_nega(self):
        """Comparison: A > m (signed), A and m both negative"""
        mpu = self._make_mpu()
        # $0000 CMP #$FE (-2), A will be -1 (0xFF)
        self._write(mpu.memory, 0x0000, (0xC9, 0xFE))
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE) # 0xFF-0xFE=0x01
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY) # A>m unsigned


    # CPX Immediate

    def test_cpx_imm_sets_zero_carry_clears_neg_flags_if_equal(self):
        """Comparison: X == m"""
        mpu = self._make_mpu()
        # $0000 CPX #$20
        self._write(mpu.memory, 0x0000, (0xE0, 0x20))
        mpu.x = 0x20
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)


    # CPY Immediate

    def test_cpy_imm_sets_zero_carry_clears_neg_flags_if_equal(self):
        """Comparison: Y == m"""
        mpu = self._make_mpu()
        # $0000 CPY #$30
        self._write(mpu.memory, 0x0000, (0xC0, 0x30))
        mpu.y = 0x30
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)




    # PHA

    def test_pha_pushes_a_and_updates_sp(self):
        mpu = self._make_mpu()
        mpu.a = 0xAB
        # $0000 PHA
        mpu.memory[0x0000] = 0x48
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.a)
        self.assertEqual(0xAB, mpu.memory[0x01FF])
        self.assertEqual(0xFE, mpu.sp)

    # PHP

    def test_php_pushes_processor_status_and_updates_sp(self):
        for flags in range(0x100):
            mpu = self._make_mpu()
            mpu.p = flags | mpu.BREAK | mpu.UNUSED
            # $0000 PHP
            mpu.memory[0x0000] = 0x08
            mpu.step()
            self.assertEqual(0x0001, mpu.pc)
            self.assertEqual((flags | mpu.BREAK | mpu.UNUSED),
                             mpu.memory[0x1FF])
            self.assertEqual(0xFE, mpu.sp)

    # PLA

    def test_pla_pulls_top_byte_from_stack_into_a_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 PLA
        mpu.memory[0x0000] = 0x68
        mpu.memory[0x01FF] = 0xAB
        mpu.sp = 0xFE
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB,   mpu.a)
        self.assertEqual(0xFF,   mpu.sp)

    # PLP

    def test_plp_pulls_top_byte_from_stack_into_flags_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 PLP
        mpu.memory[0x0000] = 0x28
        mpu.memory[0x01FF] = 0xBA  # must have BREAK and UNUSED set
        mpu.sp = 0xFE
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xBA,   mpu.p)
        self.assertEqual(0xFF,   mpu.sp)

    # RTI

    def test_rti_restores_status_and_pc_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 RTI
        mpu.memory[0x0000] = 0x40
        self._write(mpu.memory, 0x01FD, (0xFC, 0x03, 0xC0))  # Status, PCL, PCH
        mpu.sp = 0xFC

        mpu.step()
        self.assertEqual(0xC003, mpu.pc)
        self.assertEqual(0xFC,   mpu.p)
        self.assertEqual(0xFF,   mpu.sp)

    def test_rti_forces_break_and_unused_flags_high(self):
        mpu = self._make_mpu()
        # $0000 RTI
        mpu.memory[0x0000] = 0x40
        self._write(mpu.memory, 0x01FD, (0x00, 0x03, 0xC0))  # Status, PCL, PCH
        mpu.sp = 0xFC

        mpu.step()
        self.assertEqual(mpu.BREAK, mpu.p & mpu.BREAK)
        self.assertEqual(mpu.UNUSED, mpu.p & mpu.UNUSED)

    # RTS

    def test_rts_restores_pc_and_increments_then_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 RTS
        mpu.memory[0x0000] = 0x60
        self._write(mpu.memory, 0x01FE, (0x03, 0xC0))  # PCL, PCH
        mpu.pc = 0x0000
        mpu.sp = 0xFD

        mpu.step()
        self.assertEqual(0xC004, mpu.pc)
        self.assertEqual(0xFF,   mpu.sp)

    def test_rts_wraps_around_top_of_memory(self):
        mpu = self._make_mpu()
        # $1000 RTS
        mpu.memory[0x1000] = 0x60
        self._write(mpu.memory, 0x01FE, (0xFF, 0xFF))  # PCL, PCH
        mpu.pc = 0x1000
        mpu.sp = 0xFD

        mpu.step()
        self.assertEqual(0x0000, mpu.pc)
        self.assertEqual(0xFF,   mpu.sp)


    def test_decorated_addressing_modes_are_valid(self):
        valid_modes = [x[0] for x in py65.assembler.Assembler.Addressing]
        mpu = self._make_mpu()
        for name, mode in mpu.disassemble:
            self.assertTrue(mode in valid_modes)

    def test_brk_interrupt(self):
        mpu = self._make_mpu()
        mpu.p = 0x00
        self._write(mpu.memory, 0xFFFE, (0x00, 0x04))

        self._write(mpu.memory, 0x0000, (0xA9, 0x01,   # LDA #$01
                                         0x00, 0xEA,   # BRK + skipped byte
                                         0xEA, 0xEA,   # NOP, NOP
                                         0xA9, 0x03))  # LDA #$03

        self._write(mpu.memory, 0x0400, (0xA9, 0x02,   # LDA #$02
                                         0x40))        # RTI

        mpu.step()  # LDA #$01
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x0002, mpu.pc)
        mpu.step()  # BRK
        self.assertEqual(0x0400, mpu.pc)
        mpu.step()  # LDA #$02
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0x0402, mpu.pc)
        mpu.step()  # RTI

        self.assertEqual(0x0004, mpu.pc)
        mpu.step()  # A NOP
        mpu.step()  # The second NOP

        mpu.step()  # LDA #$03
        self.assertEqual(0x03, mpu.a)
        self.assertEqual(0x0008, mpu.pc)



 */
