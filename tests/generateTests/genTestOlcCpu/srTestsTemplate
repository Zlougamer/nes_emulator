/*
# ASL Accumulator

AslAccumulatorSetsZFlag(self):
    mpu = self.MakeMpu()
    mpu.a = 0x00
    # $0000 ASL A
    mpu.memory[0x0000] = 0x0A
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0x00, mpu.a)
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

AslAccumulatorSetsNFlag(self):
    mpu = self.MakeMpu()
    mpu.a = 0x40
    # $0000 ASL A
    mpu.memory[0x0000] = 0x0A
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0x80, mpu.a)
    self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
    self.assertEqual(0, mpu.p & mpu.ZERO)

AslAccumulatorShiftsOutZero(self):
    mpu = self.MakeMpu()
    mpu.a = 0x7F
    # $0000 ASL A
    mpu.memory[0x0000] = 0x0A
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0xFE, mpu.a)
    self.assertEqual(0, mpu.p & mpu.CARRY)

AslAccumulatorShiftsOutOne(self):
    mpu = self.MakeMpu()
    mpu.a = 0xFF
    # $0000 ASL A
    mpu.memory[0x0000] = 0x0A
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0xFE, mpu.a)
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

AslAccumulator_80SetsZFlag(self):
    mpu = self.MakeMpu()
    mpu.a = 0x80
    mpu.p &= ~(mpu.ZERO)
    # $0000 ASL A
    mpu.memory[0x0000] = 0x0A
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0x00, mpu.a)
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

# ASL Absolute

AslAbsoluteSetsZFlag(self):
    mpu = self.MakeMpu()
    # $0000 ASL $ABCD
    self.Write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
    mpu.memory[0xABCD] = 0x00
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0xABCD])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

AslAbsoluteSetsNFlag(self):
    mpu = self.MakeMpu()
    # $0000 ASL $ABCD
    self.Write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
    mpu.memory[0xABCD] = 0x40
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x80, mpu.memory[0xABCD])
    self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
    self.assertEqual(0, mpu.p & mpu.ZERO)

AslAbsoluteShiftsOutZero(self):
    mpu = self.MakeMpu()
    mpu.a = 0xAA
    # $0000 ASL $ABCD
    self.Write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
    mpu.memory[0xABCD] = 0x7F
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0xABCD])
    self.assertEqual(0, mpu.p & mpu.CARRY)

AslAbsoluteShiftsOutOne(self):
    mpu = self.MakeMpu()
    mpu.a = 0xAA
    # $0000 ASL $ABCD
    self.Write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
    mpu.memory[0xABCD] = 0xFF
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0xABCD])
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

# ASL Zero Page

AslZpSetsZFlag(self):
    mpu = self.MakeMpu()
    # $0000 ASL $0010
    self.Write(mpu.memory, 0x0000, (0x06, 0x10))
    mpu.memory[0x0010] = 0x00
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0x0010])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

AslZpSetsNFlag(self):
    mpu = self.MakeMpu()
    # $0000 ASL $0010
    self.Write(mpu.memory, 0x0000, (0x06, 0x10))
    mpu.memory[0x0010] = 0x40
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x80, mpu.memory[0x0010])
    self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
    self.assertEqual(0, mpu.p & mpu.ZERO)

AslZpShiftsOutZero(self):
    mpu = self.MakeMpu()
    mpu.a = 0xAA
    # $0000 ASL $0010
    self.Write(mpu.memory, 0x0000, (0x06, 0x10))
    mpu.memory[0x0010] = 0x7F
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0x0010])
    self.assertEqual(0, mpu.p & mpu.CARRY)

AslZpShiftsOutOne(self):
    mpu = self.MakeMpu()
    mpu.a = 0xAA
    # $0000 ASL $0010
    self.Write(mpu.memory, 0x0000, (0x06, 0x10))
    mpu.memory[0x0010] = 0xFF
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0x0010])
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

# ASL Absolute, X-Indexed

AslAbsXIndexedSetsZFlag(self):
    mpu = self.MakeMpu()
    mpu.x = 0x03
    # $0000 ASL $ABCD,X
    self.Write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
    mpu.memory[0xABCD + mpu.x] = 0x00
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

AslAbsXIndexedSetsNFlag(self):
    mpu = self.MakeMpu()
    mpu.x = 0x03
    # $0000 ASL $ABCD,X
    self.Write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
    mpu.memory[0xABCD + mpu.x] = 0x40
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x80, mpu.memory[0xABCD + mpu.x])
    self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
    self.assertEqual(0, mpu.p & mpu.ZERO)

AslAbsXIndexedShiftsOutZero(self):
    mpu = self.MakeMpu()
    mpu.a = 0xAA
    mpu.x = 0x03
    # $0000 ASL $ABCD,X
    self.Write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
    mpu.memory[0xABCD + mpu.x] = 0x7F
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0xABCD + mpu.x])
    self.assertEqual(0, mpu.p & mpu.CARRY)

AslAbsXIndexedShiftsOutOne(self):
    mpu = self.MakeMpu()
    mpu.a = 0xAA
    mpu.x = 0x03
    # $0000 ASL $ABCD,X
    self.Write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
    mpu.memory[0xABCD + mpu.x] = 0xFF
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0xABCD + mpu.x])
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

# ASL Zero Page, X-Indexed

AslZpXIndexedSetsZFlag(self):
    mpu = self.MakeMpu()
    mpu.x = 0x03
    # $0000 ASL $0010,X
    self.Write(mpu.memory, 0x0000, (0x16, 0x10))
    mpu.memory[0x0010 + mpu.x] = 0x00
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

AslZpXIndexedSetsNFlag(self):
    mpu = self.MakeMpu()
    mpu.x = 0x03
    # $0000 ASL $0010,X
    self.Write(mpu.memory, 0x0000, (0x16, 0x10))
    mpu.memory[0x0010 + mpu.x] = 0x40
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x80, mpu.memory[0x0010 + mpu.x])
    self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
    self.assertEqual(0, mpu.p & mpu.ZERO)

AslZpXIndexedShiftsOutZero(self):
    mpu = self.MakeMpu()
    mpu.x = 0x03
    mpu.a = 0xAA
    # $0000 ASL $0010,X
    self.Write(mpu.memory, 0x0000, (0x16, 0x10))
    mpu.memory[0x0010 + mpu.x] = 0x7F
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0x0010 + mpu.x])
    self.assertEqual(0, mpu.p & mpu.CARRY)

AslZpXIndexedShiftsOutOne(self):
    mpu = self.MakeMpu()
    mpu.x = 0x03
    mpu.a = 0xAA
    # $0000 ASL $0010,X
    self.Write(mpu.memory, 0x0000, (0x16, 0x10))
    mpu.memory[0x0010 + mpu.x] = 0xFF
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0xAA, mpu.a)
    self.assertEqual(0xFE, mpu.memory[0x0010 + mpu.x])
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)


# LSR Accumulator

LsrAccumulatorRotatesInZeroNotCarry(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    # $0000 LSR A
    mpu.memory[0x0000] = (0x4A)
    mpu.a = 0x00
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0x00, mpu.a)
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrAccumulatorSetsCarryAndZeroFlagsAfterRotation(self):
    mpu = self.MakeMpu()
    mpu.p &= ~mpu.CARRY
    # $0000 LSR A
    mpu.memory[0x0000] = (0x4A)
    mpu.a = 0x01
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0x00, mpu.a)
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrAccumulatorRotatesBitsRight(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    # $0000 LSR A
    mpu.memory[0x0000] = (0x4A)
    mpu.a = 0x04
    mpu.step()
    self.assertEqual(0x0001, mpu.pc)
    self.assertEqual(0x02, mpu.a)
    self.assertEqual(0, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

# LSR Absolute

LsrAbsoluteRotatesInZeroNotCarry(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    # $0000 LSR $ABCD
    self.Write(mpu.memory, 0x0000, (0x4E, 0xCD, 0xAB))
    mpu.memory[0xABCD] = 0x00
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0xABCD])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrAbsoluteSetsCarryAndZeroFlagsAfterRotation(self):
    mpu = self.MakeMpu()
    mpu.p &= ~mpu.CARRY
    # $0000 LSR $ABCD
    self.Write(mpu.memory, 0x0000, (0x4E, 0xCD, 0xAB))
    mpu.memory[0xABCD] = 0x01
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0xABCD])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrAbsoluteRotatesBitsRight(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    # $0000 LSR $ABCD
    self.Write(mpu.memory, 0x0000, (0x4E, 0xCD, 0xAB))
    mpu.memory[0xABCD] = 0x04
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x02, mpu.memory[0xABCD])
    self.assertEqual(0, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

# LSR Zero Page

LsrZpRotatesInZeroNotCarry(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    # $0000 LSR $0010
    self.Write(mpu.memory, 0x0000, (0x46, 0x10))
    mpu.memory[0x0010] = 0x00
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0x0010])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrZpSetsCarryAndZeroFlagsAfterRotation(self):
    mpu = self.MakeMpu()
    mpu.p &= ~mpu.CARRY
    # $0000 LSR $0010
    self.Write(mpu.memory, 0x0000, (0x46, 0x10))
    mpu.memory[0x0010] = 0x01
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0x0010])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrZpRotatesBitsRight(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    # $0000 LSR $0010
    self.Write(mpu.memory, 0x0000, (0x46, 0x10))
    mpu.memory[0x0010] = 0x04
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x02, mpu.memory[0x0010])
    self.assertEqual(0, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

# LSR Absolute, X-Indexed

LsrAbsXIndexedRotatesInZeroNotCarry(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    mpu.x = 0x03
    # $0000 LSR $ABCD,X
    self.Write(mpu.memory, 0x0000, (0x5E, 0xCD, 0xAB))
    mpu.memory[0xABCD + mpu.x] = 0x00
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrAbsXIndexedSetsCAndZFlagsAfterRotation(self):
    mpu = self.MakeMpu()
    mpu.p &= ~mpu.CARRY
    mpu.x = 0x03
    # $0000 LSR $ABCD,X
    self.Write(mpu.memory, 0x0000, (0x5E, 0xCD, 0xAB))
    mpu.memory[0xABCD + mpu.x] = 0x01
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrAbsXIndexedRotatesBitsRight(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    # $0000 LSR $ABCD,X
    self.Write(mpu.memory, 0x0000, (0x5E, 0xCD, 0xAB))
    mpu.memory[0xABCD + mpu.x] = 0x04
    mpu.step()
    self.assertEqual(0x0003, mpu.pc)
    self.assertEqual(0x02, mpu.memory[0xABCD + mpu.x])
    self.assertEqual(0, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

# LSR Zero Page, X-Indexed

LsrZpXIndexedRotatesInZeroNotCarry(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    mpu.x = 0x03
    # $0000 LSR $0010,X
    self.Write(mpu.memory, 0x0000, (0x56, 0x10))
    mpu.memory[0x0010 + mpu.x] = 0x00
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrZpXIndexedSetsCarryAndZeroFlagsAfterRotation(self):
    mpu = self.MakeMpu()
    mpu.p &= ~mpu.CARRY
    mpu.x = 0x03
    # $0000 LSR $0010,X
    self.Write(mpu.memory, 0x0000, (0x56, 0x10))
    mpu.memory[0x0010 + mpu.x] = 0x01
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
    self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
    self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

LsrZpXIndexedRotatesBitsRight(self):
    mpu = self.MakeMpu()
    mpu.p |= mpu.CARRY
    mpu.x = 0x03
    # $0000 LSR $0010,X
    self.Write(mpu.memory, 0x0000, (0x56, 0x10))
    mpu.memory[0x0010 + mpu.x] = 0x04
    mpu.step()
    self.assertEqual(0x0002, mpu.pc)
    self.assertEqual(0x02, mpu.memory[0x0010 + mpu.x])
    self.assertEqual(0, mpu.p & mpu.ZERO)
    self.assertEqual(0, mpu.p & mpu.CARRY)
    self.assertEqual(0, mpu.p & mpu.NEGATIVE)

 */
