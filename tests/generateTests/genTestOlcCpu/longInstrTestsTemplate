    # PHP

    PhpPushesProcessorStatusAndUpdatesSp(self):
        for flags in range(0x100):
            mpu = self.MakeMpu()
            mpu.p = flags | mpu.BREAK | mpu.UNUSED
            # $0000 PHP
            mpu.memory[0x0000] = 0x08
            mpu.step()
            self.assertEqual(0x0001, mpu.pc)
            self.assertEqual((flags | mpu.BREAK | mpu.UNUSED),
                             mpu.memory[0x1FF])
            self.assertEqual(0xFE, mpu.sp)


    BrkInterrupt(self):
        mpu = self.MakeMpu()
        mpu.p = 0x00
        self.Write(mpu.memory, 0xFFFE, (0x00, 0x04))

        self.Write(mpu.memory, 0x0000, (0xA9, 0x01,   # LDA #$01
                                         0x00, 0xEA,   # BRK + skipped byte
                                         0xEA, 0xEA,   # NOP, NOP
                                         0xA9, 0x03))  # LDA #$03

        self.Write(mpu.memory, 0x0400, (0xA9, 0x02,   # LDA #$02
                                         0x40))        # RTI

        mpu.step()  # LDA #$01
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x0002, mpu.pc)
        mpu.step()  # BRK
        self.assertEqual(0x0400, mpu.pc)
        mpu.step()  # LDA #$02
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0x0402, mpu.pc)
        mpu.step()  # RTI

        self.assertEqual(0x0004, mpu.pc)
        mpu.step()  # A NOP
        mpu.step()  # The second NOP

        mpu.step()  # LDA #$03
        self.assertEqual(0x03, mpu.a)
        self.assertEqual(0x0008, mpu.pc)



class MPUTests(unittest.TestCase, Common6502Tests):
    """ NMOS 6502 tests """

    Repr(self):
        mpu = self.MakeMpu()
        self.assertTrue("6502" in repr(mpu))

    # ADC Indirect, Indexed (X)

    AdcIndIndexedHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.p = 0x00
        mpu.a = 0x01
        mpu.x = 0xFF
        # $0000 ADC ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self.Write(mpu.memory, 0x0000, (0x61, 0x80))
        self.Write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self.Write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.memory[0xBBBB] = 0x02
        mpu.step()
        self.assertEqual(0x03, mpu.a)

    # ADC Indexed, Indirect (Y)

    AdcIndexedIndYHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.pc = 0x1000
        mpu.p = 0
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 ADC ($FF),Y
        self.Write(mpu.memory, 0x1000, (0x71, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x14 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(0x84, mpu.a)

    # LDA Zero Page, X-Indexed

    LdaZpXIndexedPageWraps(self):
        mpu = self.MakeMpu()
        mpu.a = 0x00
        mpu.x = 0xFF
        # $0000 LDA $80,X
        self.Write(mpu.memory, 0x0000, (0xB5, 0x80))
        mpu.memory[0x007F] = 0x42
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x42, mpu.a)

    # AND Indexed, Indirect (Y)

    AndIndexedIndYHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.pc = 0x1000
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 AND ($FF),Y
        self.Write(mpu.memory, 0x1000, (0x31, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x00 # read if no page wrap
        mpu.memory[0x0012] = 0xFF # read if page wrapped
        mpu.step()
        self.assertEqual(0x42, mpu.a)

    # BRK

    BrkPreservesDecimalFlagWhenItIsSet(self):
        mpu = self.MakeMpu()
        mpu.p = mpu.DECIMAL
        # $C000 BRK
        mpu.memory[0xC000] = 0x00
        mpu.pc = 0xC000
        mpu.step()
        self.assertEqual(mpu.BREAK, mpu.p & mpu.BREAK)
        self.assertEqual(mpu.DECIMAL, mpu.p & mpu.DECIMAL)

    BrkPreservesDecimalFlagWhenItIsClear(self):
        mpu = self.MakeMpu()
        mpu.p = 0
        # $C000 BRK
        mpu.memory[0xC000] = 0x00
        mpu.pc = 0xC000
        mpu.step()
        self.assertEqual(mpu.BREAK, mpu.p & mpu.BREAK)
        self.assertEqual(0, mpu.p & mpu.DECIMAL)

    # CMP Indirect, Indexed (X)

    CmpIndXHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.p = 0
        mpu.a = 0x42
        mpu.x = 0xFF
        # $0000 CMP ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self.Write(mpu.memory, 0x0000, (0xC1, 0x80))
        self.Write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self.Write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.memory[0xBBBB] = 0x42
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # CMP Indexed, Indirect (Y)

    CmpIndexedIndYHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.pc = 0x1000
        mpu.p = 0
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 CMP ($FF),Y
        self.Write(mpu.memory, 0x1000, (0xd1, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x14 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # EOR Indirect, Indexed (X)

    EorIndXHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.p = 0
        mpu.a = 0xAA
        mpu.x = 0xFF
        # $0000 EOR ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self.Write(mpu.memory, 0x0000, (0x41, 0x80))
        self.Write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self.Write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.memory[0xBBBB] = 0xFF
        mpu.step()
        self.assertEqual(0x55, mpu.a)

    # EOR Indexed, Indirect (Y)

    EorIndexedIndYHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.pc = 0x1000
        mpu.a = 0xAA
        mpu.y = 0x02
        # $1000 EOR ($FF),Y
        self.Write(mpu.memory, 0x1000, (0x51, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x00 # read if no page wrap
        mpu.memory[0x0012] = 0xFF # read if page wrapped
        mpu.step()
        self.assertEqual(0x55, mpu.a)

    # LDA Indirect, Indexed (X)

    LdaIndIndexedXHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.a = 0x00
        mpu.x = 0xff
        # $0000 LDA ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self.Write(mpu.memory, 0x0000, (0xA1, 0x80))
        self.Write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self.Write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x42
        mpu.memory[0xBBBB] = 0xEF
        mpu.step()
        self.assertEqual(0xEF, mpu.a)

    # LDA Indexed, Indirect (Y)

    LdaIndexedIndYHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.pc = 0x1000
        mpu.a = 0x00
        mpu.y = 0x02
        # $1000 LDA ($FF),Y
        self.Write(mpu.memory, 0x1000, (0xb1, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x14 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(0x42, mpu.a)

    # LDA Zero Page, X-Indexed

    LdaZpXHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.a = 0x00
        mpu.x = 0xFF
        # $0000 LDA $80,X
        self.Write(mpu.memory, 0x0000, (0xB5, 0x80))
        mpu.memory[0x007F] = 0x42
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x42, mpu.a)

    # JMP Indirect

    JmpJumpsToAddressWithPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.memory[0x00ff] = 0
        # $0000 JMP ($00)
        self.Write(mpu.memory, 0, (0x6c, 0xff, 0x00))
        mpu.step()
        self.assertEqual(0x6c00, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)

    # ORA Indexed, Indirect (Y)

    OraIndexedIndYHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.pc = 0x1000
        mpu.a = 0x00
        mpu.y = 0x02
        # $1000 ORA ($FF),Y
        self.Write(mpu.memory, 0x1000, (0x11, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x00 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(0x42, mpu.a)

    # SBC Indexed, Indirect (Y)

    SbcIndexedIndYHasPageWrapBug(self):
        mpu = self.MakeMpu()
        mpu.pc = 0x1000
        mpu.p = mpu.CARRY
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 SBC ($FF),Y
        self.Write(mpu.memory, 0x1000, (0xf1, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x02 # read if no page wrap
        mpu.memory[0x0012] = 0x03 # read if page wrapped
        mpu.step()
        self.assertEqual(0x3f, mpu.a)

 */
