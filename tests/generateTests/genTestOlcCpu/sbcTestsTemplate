/*
package main

import (
    "flag"
    "os"
    "text/template"
)

type data struct {
    Type string
    Name string
}

func main() {
    var d data
    flag.StringVar(&d.Type, "type", "", "The subtype used for the queue being generated")
    flag.StringVar(&d.Name, "name", "", "The name used for the queue being generated. This should start with a capital letter so that it is exported.")
    flag.Parse()

    t := template.Must(template.New("queue").Parse(queueTemplate))
    if err := t.Execute(os.Stdout, d); err != nil {
        panic(err)
    }
}

var queueTemplate = `
package queue

import (
  "container/list"
)

func New{{.Name}}() *{{.Name}} {
  return &{{.Name}}{list.New()}
}

type {{.Name}} struct {
  list *list.List
}

func (q *{{.Name}}) Len() int {
  return q.list.Len()
}

func (q *{{.Name}}) Enqueue(i {{.Type}}) {
  q.list.PushBack(i)
}

func (q *{{.Name}}) Dequeue() {{.Type}} {
  if q.list.Len() == 0 {
    panic(ErrEmptyQueue)
  }
  raw := q.list.Remove(q.list.Front())
  if typed, ok := raw.({{.Type}}); ok {
    return typed
  }
  panic(ErrInvalidType)
}
`

//
//
//# SBC Absolute
//
//def test_sbc_abs_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//# $0000 SBC $ABCD
//self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
//mpu.memory[0xABCD] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC $ABCD
//self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
//mpu.memory[0xABCD] = 0x01
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# $0000 SBC $ABCD
//self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
//mpu.memory[0xABCD] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# $0000 SBC $ABCD
//self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
//mpu.memory[0xABCD] = 0x02
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//
//# SBC Zero Page
//
//def test_sbc_zp_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//# $0000 SBC $10
//self._write(mpu.memory, 0x0000, (0xE5, 0x10))
//mpu.memory[0x0010] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_zp_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC $10
//self._write(mpu.memory, 0x0000, (0xE5, 0x10))
//mpu.memory[0x0010] = 0x01
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_zp_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# => SBC $10
//self._write(mpu.memory, 0x0000, (0xE5, 0x10))
//mpu.memory[0x0010] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_zp_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# => SBC $10
//self._write(mpu.memory, 0x0000, (0xE5, 0x10))
//mpu.memory[0x0010] = 0x02
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//
//# SBC Immediate
//
//def test_sbc_imm_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//# $0000 SBC #$00
//self._write(mpu.memory, 0x0000, (0xE9, 0x00))
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_imm_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC #$01
//self._write(mpu.memory, 0x0000, (0xE9, 0x01))
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_imm_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# $0000 SBC #$00
//self._write(mpu.memory, 0x0000, (0xE9, 0x00))
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_imm_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# $0000 SBC #$02
//self._write(mpu.memory, 0x0000, (0xE9, 0x02))
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//
//def test_sbc_bcd_on_immediate_0a_minus_00_carry_set(self):
//mpu = self._make_mpu()
//mpu.p |= mpu.DECIMAL
//mpu.p |= mpu.CARRY
//mpu.a = 0x0a
//# $0000 SBC #$00
//self._write(mpu.memory, 0x0000, (0xe9, 0x00))
//mpu.step()
//self.assertEqual(0x0002, mpu.pc)
//self.assertEqual(0x0a, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.OVERFLOW)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
//
//def test_sbc_bcd_on_immediate_9a_minus_00_carry_set(self):
//mpu = self._make_mpu()
//mpu.p |= mpu.DECIMAL
//mpu.p |= mpu.CARRY
//mpu.a = 0x9a
//#$0000 SBC #$00
//self._write(mpu.memory, 0x0000, (0xe9, 0x00))
//mpu.step()
//self.assertEqual(0x0002, mpu.pc)
//self.assertEqual(0x9a, mpu.a)
//self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.OVERFLOW)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
//
//def test_sbc_bcd_on_immediate_00_minus_01_carry_set(self):
//mpu = self._make_mpu()
//mpu.p |= mpu.DECIMAL
//mpu.p |= mpu.OVERFLOW
//mpu.p |= mpu.ZERO
//mpu.p |= mpu.CARRY
//mpu.a = 0x00
//# => $0000 SBC #$00
//self._write(mpu.memory, 0x0000, (0xe9, 0x01))
//mpu.step()
//self.assertEqual(0x0002, mpu.pc)
//self.assertEqual(0x99, mpu.a)
//self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.OVERFLOW)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(0, mpu.p & mpu.CARRY)
//
//def test_sbc_bcd_on_immediate_20_minus_0a_carry_unset(self):
//mpu = self._make_mpu()
//mpu.p |= mpu.DECIMAL
//mpu.a = 0x20
//# $0000 SBC #$00
//self._write(mpu.memory, 0x0000, (0xe9, 0x0a))
//mpu.step()
//self.assertEqual(0x0002, mpu.pc)
//self.assertEqual(0x1f, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.OVERFLOW)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
//
//# SBC Absolute, X-Indexed
//
//def test_sbc_abs_x_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//# $0000 SBC $FEE0,X
//self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
//mpu.x = 0x0D
//mpu.memory[0xFEED] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_x_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC $FEE0,X
//self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
//mpu.x = 0x0D
//mpu.memory[0xFEED] = 0x01
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_x_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# $0000 SBC $FEE0,X
//self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
//mpu.x = 0x0D
//mpu.memory[0xFEED] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_x_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# $0000 SBC $FEE0,X
//self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
//mpu.x = 0x0D
//mpu.memory[0xFEED] = 0x02
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//
//# SBC Absolute, Y-Indexed
//
//def test_sbc_abs_y_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//# $0000 SBC $FEE0,Y
//self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
//mpu.y = 0x0D
//mpu.memory[0xFEED] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_y_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC $FEE0,Y
//self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
//mpu.y = 0x0D
//mpu.memory[0xFEED] = 0x01
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_y_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# $0000 SBC $FEE0,Y
//self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
//mpu.y = 0x0D
//mpu.memory[0xFEED] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_abs_y_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# $0000 SBC $FEE0,Y
//self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
//mpu.y = 0x0D
//mpu.memory[0xFEED] = 0x02
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//
//# SBC Indirect, Indexed (X)
//
//def test_sbc_ind_x_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//# $0000 SBC ($10,X)
//# $0013 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xE1, 0x10))
//self._write(mpu.memory, 0x0013, (0xED, 0xFE))
//mpu.x = 0x03
//mpu.memory[0xFEED] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_ind_x_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC ($10,X)
//# $0013 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xE1, 0x10))
//self._write(mpu.memory, 0x0013, (0xED, 0xFE))
//mpu.x = 0x03
//mpu.memory[0xFEED] = 0x01
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_ind_x_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# $0000 SBC ($10,X)
//# $0013 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xE1, 0x10))
//self._write(mpu.memory, 0x0013, (0xED, 0xFE))
//mpu.x = 0x03
//mpu.memory[0xFEED] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_ind_x_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# $0000 SBC ($10,X)
//# $0013 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xE1, 0x10))
//self._write(mpu.memory, 0x0013, (0xED, 0xFE))
//mpu.x = 0x03
//mpu.memory[0xFEED] = 0x02
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//
//# SBC Indexed, Indirect (Y)
//
//def test_sbc_ind_y_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//mpu.y = 0x03
//# $0000 SBC ($10),Y
//# $0010 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xF1, 0x10))
//self._write(mpu.memory, 0x0010, (0xED, 0xFE))
//mpu.memory[0xFEED + mpu.y] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_ind_y_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC ($10),Y
//# $0010 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xF1, 0x10))
//self._write(mpu.memory, 0x0010, (0xED, 0xFE))
//mpu.memory[0xFEED + mpu.y] = 0x01
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_ind_y_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# $0000 SBC ($10),Y
//# $0010 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xF1, 0x10))
//self._write(mpu.memory, 0x0010, (0xED, 0xFE))
//mpu.memory[0xFEED + mpu.y] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_ind_y_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# $0000 SBC ($10),Y
//# $0010 Vector to $FEED
//self._write(mpu.memory, 0x0000, (0xF1, 0x10))
//self._write(mpu.memory, 0x0010, (0xED, 0xFE))
//mpu.memory[0xFEED + mpu.y] = 0x02
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//
//# SBC Zero Page, X-Indexed
//
//def test_sbc_zp_x_all_zeros_and_no_borrow_is_zero(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x00
//# $0000 SBC $10,X
//self._write(mpu.memory, 0x0000, (0xF5, 0x10))
//mpu.x = 0x0D
//mpu.memory[0x001D] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_zp_x_downto_zero_no_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p |= mpu.CARRY  # borrow = 0
//mpu.a = 0x01
//# $0000 SBC $10,X
//self._write(mpu.memory, 0x0000, (0xF5, 0x10))
//mpu.x = 0x0D
//mpu.memory[0x001D] = 0x01
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_zp_x_downto_zero_with_borrow_sets_z_clears_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x01
//# $0000 SBC $10,X
//self._write(mpu.memory, 0x0000, (0xF5, 0x10))
//mpu.x = 0x0D
//mpu.memory[0x001D] = 0x00
//mpu.step()
//self.assertEqual(0x00, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(mpu.CARRY, mpu.CARRY)
//self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
//
//def test_sbc_zp_x_downto_four_with_borrow_clears_z_n(self):
//mpu = self._make_mpu()
//mpu.p &= ~(mpu.DECIMAL)
//mpu.p &= ~(mpu.CARRY)  # borrow = 1
//mpu.a = 0x07
//# $0000 SBC $10,X
//self._write(mpu.memory, 0x0000, (0xF5, 0x10))
//mpu.x = 0x0D
//mpu.memory[0x001D] = 0x02
//mpu.step()
//self.assertEqual(0x04, mpu.a)
//self.assertEqual(0, mpu.p & mpu.NEGATIVE)
//self.assertEqual(0, mpu.p & mpu.ZERO)
//self.assertEqual(mpu.CARRY, mpu.CARRY)

