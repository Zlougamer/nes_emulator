/*
package main

import (
    "flag"
    "os"
    "text/template"
)

type data struct {
    Type string
    Name string
}

func main() {
    var d data
    flag.StringVar(&d.Type, "type", "", "The subtype used for the queue being generated")
    flag.StringVar(&d.Name, "name", "", "The name used for the queue being generated. This should start with a capital letter so that it is exported.")
    flag.Parse()

    t := template.Must(template.New("queue").Parse(queueTemplate))
    if err := t.Execute(os.Stdout, d); err != nil {
        panic(err)
    }
}

var queueTemplate = `
package queue

import (
  "container/list"
)

func New{{.Name}}() *{{.Name}} {
  return &{{.Name}}{list.New()}
}

type {{.Name}} struct {
  list *list.List
}

func (q *{{.Name}}) Len() int {
  return q.list.Len()
}

func (q *{{.Name}}) Enqueue(i {{.Type}}) {
  q.list.PushBack(i)
}

func (q *{{.Name}}) Dequeue() {{.Type}} {
  if q.list.Len() == 0 {
    panic(ErrEmptyQueue)
  }
  raw := q.list.Remove(q.list.Front())
  if typed, ok := raw.({{.Type}}); ok {
    return typed
  }
  panic(ErrInvalidType)
}
`
*/
/*

    # BCC

    def test_bcc_carry_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 BCC +6
        self._write(mpu.memory, 0x0000, (0x90, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bcc_carry_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        # $0000 BCC -6
        self._write(mpu.memory, 0x0050, (0x90, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_bcc_carry_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 BCC +6
        self._write(mpu.memory, 0x0000, (0x90, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BCS

    def test_bcs_carry_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 BCS +6
        self._write(mpu.memory, 0x0000, (0xB0, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bcs_carry_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        # $0000 BCS -6
        self._write(mpu.memory, 0x0050, (0xB0, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_bcs_carry_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 BCS +6
        self._write(mpu.memory, 0x0000, (0xB0, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BEQ

    def test_beq_zero_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BEQ +6
        self._write(mpu.memory, 0x0000, (0xF0, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_beq_zero_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        # $0000 BEQ -6
        self._write(mpu.memory, 0x0050, (0xF0, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_beq_zero_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BEQ +6
        self._write(mpu.memory, 0x0000, (0xF0, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)


    # BMI

    def test_bmi_negative_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BMI +06
        self._write(mpu.memory, 0x0000, (0x30, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bmi_negative_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        mpu.pc = 0x0050
        # $0000 BMI -6
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        self._write(mpu.memory, 0x0050, (0x30, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_bmi_negative_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BEQ +6
        self._write(mpu.memory, 0x0000, (0x30, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BNE

    def test_bne_zero_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BNE +6
        self._write(mpu.memory, 0x0000, (0xD0, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bne_zero_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.pc = 0x0050
        # $0050 BNE -6
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        self._write(mpu.memory, 0x0050, (0xD0, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_bne_zero_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BNE +6
        self._write(mpu.memory, 0x0000, (0xD0, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BPL

    def test_bpl_negative_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BPL +06
        self._write(mpu.memory, 0x0000, (0x10, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bpl_negative_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.pc = 0x0050
        # $0050 BPL -6
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        self._write(mpu.memory, 0x0050, (0x10, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_bpl_negative_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BPL +6
        self._write(mpu.memory, 0x0000, (0x10, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)


    # BVC

    def test_bvc_overflow_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BVC +6
        self._write(mpu.memory, 0x0000, (0x50, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bvc_overflow_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        # $0050 BVC -6
        self._write(mpu.memory, 0x0050, (0x50, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_bvc_overflow_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BVC +6
        self._write(mpu.memory, 0x0000, (0x50, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BVS

    def test_bvs_overflow_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BVS +6
        self._write(mpu.memory, 0x0000, (0x70, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bvs_overflow_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF) + 1  # two's complement of 6
        # $0050 BVS -6
        self._write(mpu.memory, 0x0050, (0x70, rel))
        mpu.step()
        self.assertEqual(0x0052 - 0x06, mpu.pc)

    def test_bvs_overflow_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BVS +6
        self._write(mpu.memory, 0x0000, (0x70, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

 */
